// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: messages.proto
// Protobuf C++ Version: 5.29.5

#ifndef messages_2eproto_2epb_2eh
#define messages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_messages_2eproto;
class AuthResponse;
struct AuthResponseDefaultTypeInternal;
extern AuthResponseDefaultTypeInternal _AuthResponse_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class FileMessage;
struct FileMessageDefaultTypeInternal;
extern FileMessageDefaultTypeInternal _FileMessage_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class VoiceMessage;
struct VoiceMessageDefaultTypeInternal;
extern VoiceMessageDefaultTypeInternal _VoiceMessage_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum UserStatus : int {
  OFFLINE = 0,
  ONLINE = 1,
  AWAY = 2,
  DO_NOT_DISTURB = 3,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UserStatus_IsValid(int value);
extern const uint32_t UserStatus_internal_data_[];
constexpr UserStatus UserStatus_MIN = static_cast<UserStatus>(0);
constexpr UserStatus UserStatus_MAX = static_cast<UserStatus>(3);
constexpr int UserStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UserStatus_descriptor();
template <typename T>
const std::string& UserStatus_Name(T value) {
  static_assert(std::is_same<T, UserStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UserStatus_Name().");
  return UserStatus_Name(static_cast<UserStatus>(value));
}
template <>
inline const std::string& UserStatus_Name(UserStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UserStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UserStatus_Parse(absl::string_view name, UserStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserStatus>(
      UserStatus_descriptor(), name, value);
}
enum MessageType : int {
  TEXT = 0,
  SYSTEM = 1,
  JOIN = 2,
  LEAVE = 3,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MessageType_IsValid(int value);
extern const uint32_t MessageType_internal_data_[];
constexpr MessageType MessageType_MIN = static_cast<MessageType>(0);
constexpr MessageType MessageType_MAX = static_cast<MessageType>(3);
constexpr int MessageType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
MessageType_descriptor();
template <typename T>
const std::string& MessageType_Name(T value) {
  static_assert(std::is_same<T, MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return MessageType_Name(static_cast<MessageType>(value));
}
template <>
inline const std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MessageType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
      MessageType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VoiceMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:VoiceMessage) */ {
 public:
  inline VoiceMessage() : VoiceMessage(nullptr) {}
  ~VoiceMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VoiceMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VoiceMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VoiceMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline VoiceMessage(const VoiceMessage& from) : VoiceMessage(nullptr, from) {}
  inline VoiceMessage(VoiceMessage&& from) noexcept
      : VoiceMessage(nullptr, std::move(from)) {}
  inline VoiceMessage& operator=(const VoiceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceMessage& operator=(VoiceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoiceMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoiceMessage* internal_default_instance() {
    return reinterpret_cast<const VoiceMessage*>(
        &_VoiceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(VoiceMessage& a, VoiceMessage& b) { a.Swap(&b); }
  inline void Swap(VoiceMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoiceMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VoiceMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VoiceMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VoiceMessage& from) { VoiceMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VoiceMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "VoiceMessage"; }

 protected:
  explicit VoiceMessage(::google::protobuf::Arena* arena);
  VoiceMessage(::google::protobuf::Arena* arena, const VoiceMessage& from);
  VoiceMessage(::google::protobuf::Arena* arena, VoiceMessage&& from) noexcept
      : VoiceMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAudioDataFieldNumber = 1,
    kDurationSecondsFieldNumber = 2,
  };
  // bytes audio_data = 1;
  void clear_audio_data() ;
  const std::string& audio_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_data(Arg_&& arg, Args_... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* value);

  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(
      const std::string& value);
  std::string* _internal_mutable_audio_data();

  public:
  // int32 duration_seconds = 2;
  void clear_duration_seconds() ;
  ::int32_t duration_seconds() const;
  void set_duration_seconds(::int32_t value);

  private:
  ::int32_t _internal_duration_seconds() const;
  void _internal_set_duration_seconds(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:VoiceMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VoiceMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr audio_data_;
    ::int32_t duration_seconds_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class User final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(User* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(User));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR User(
      ::google::protobuf::internal::ConstantInitialized);

  inline User(const User& from) : User(nullptr, from) {}
  inline User(User&& from) noexcept
      : User(nullptr, std::move(from)) {}
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
        &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(User& a, User& b) { a.Swap(&b); }
  inline void Swap(User* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const User& from) { User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(User* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "User"; }

 protected:
  explicit User(::google::protobuf::Arena* arena);
  User(::google::protobuf::Arena* arena, const User& from);
  User(::google::protobuf::Arena* arena, User&& from) noexcept
      : User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kDisplayNameFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string username = 2;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string display_name = 3;
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // .UserStatus status = 4;
  void clear_status() ;
  ::UserStatus status() const;
  void set_status(::UserStatus value);

  private:
  ::UserStatus _internal_status() const;
  void _internal_set_status(::UserStatus value);

  public:
  // @@protoc_insertion_point(class_scope:User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      40, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const User& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterRequest(const RegisterRequest& from) : RegisterRequest(nullptr, from) {}
  inline RegisterRequest(RegisterRequest&& from) noexcept
      : RegisterRequest(nullptr, std::move(from)) {}
  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
        &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RegisterRequest& a, RegisterRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterRequest& from) { RegisterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "RegisterRequest"; }

 protected:
  explicit RegisterRequest(::google::protobuf::Arena* arena);
  RegisterRequest(::google::protobuf::Arena* arena, const RegisterRequest& from);
  RegisterRequest(::google::protobuf::Arena* arena, RegisterRequest&& from) noexcept
      : RegisterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kEmailFieldNumber = 3,
    kDisplayNameFieldNumber = 4,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // string email = 3;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string display_name = 4;
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // @@protoc_insertion_point(class_scope:RegisterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LoginRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LoginRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginRequest(const LoginRequest& from) : LoginRequest(nullptr, from) {}
  inline LoginRequest(LoginRequest&& from) noexcept
      : LoginRequest(nullptr, std::move(from)) {}
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
        &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(LoginRequest& a, LoginRequest& b) { a.Swap(&b); }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LoginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from) { LoginRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LoginRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "LoginRequest"; }

 protected:
  explicit LoginRequest(::google::protobuf::Arena* arena);
  LoginRequest(::google::protobuf::Arena* arena, const LoginRequest& from);
  LoginRequest(::google::protobuf::Arena* arena, LoginRequest&& from) noexcept
      : LoginRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:LoginRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FileMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:FileMessage) */ {
 public:
  inline FileMessage() : FileMessage(nullptr) {}
  ~FileMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FileMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FileMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline FileMessage(const FileMessage& from) : FileMessage(nullptr, from) {}
  inline FileMessage(FileMessage&& from) noexcept
      : FileMessage(nullptr, std::move(from)) {}
  inline FileMessage& operator=(const FileMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMessage& operator=(FileMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileMessage* internal_default_instance() {
    return reinterpret_cast<const FileMessage*>(
        &_FileMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(FileMessage& a, FileMessage& b) { a.Swap(&b); }
  inline void Swap(FileMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FileMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileMessage& from) { FileMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FileMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "FileMessage"; }

 protected:
  explicit FileMessage(::google::protobuf::Arena* arena);
  FileMessage(::google::protobuf::Arena* arena, const FileMessage& from);
  FileMessage(::google::protobuf::Arena* arena, FileMessage&& from) noexcept
      : FileMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFileNameFieldNumber = 1,
    kFileDataFieldNumber = 2,
    kFileSizeFieldNumber = 3,
  };
  // string file_name = 1;
  void clear_file_name() ;
  const std::string& file_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* value);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // bytes file_data = 2;
  void clear_file_data() ;
  const std::string& file_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_data(Arg_&& arg, Args_... args);
  std::string* mutable_file_data();
  PROTOBUF_NODISCARD std::string* release_file_data();
  void set_allocated_file_data(std::string* value);

  private:
  const std::string& _internal_file_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_data(
      const std::string& value);
  std::string* _internal_mutable_file_data();

  public:
  // int64 file_size = 3;
  void clear_file_size() ;
  ::int64_t file_size() const;
  void set_file_size(::int64_t value);

  private:
  ::int64_t _internal_file_size() const;
  void _internal_set_file_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:FileMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      29, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FileMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr file_name_;
    ::google::protobuf::internal::ArenaStringPtr file_data_;
    ::int64_t file_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class AuthResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AuthResponse) */ {
 public:
  inline AuthResponse() : AuthResponse(nullptr) {}
  ~AuthResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AuthResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AuthResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AuthResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline AuthResponse(const AuthResponse& from) : AuthResponse(nullptr, from) {}
  inline AuthResponse(AuthResponse&& from) noexcept
      : AuthResponse(nullptr, std::move(from)) {}
  inline AuthResponse& operator=(const AuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthResponse& operator=(AuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthResponse* internal_default_instance() {
    return reinterpret_cast<const AuthResponse*>(
        &_AuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(AuthResponse& a, AuthResponse& b) { a.Swap(&b); }
  inline void Swap(AuthResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AuthResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AuthResponse& from) { AuthResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AuthResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AuthResponse"; }

 protected:
  explicit AuthResponse(::google::protobuf::Arena* arena);
  AuthResponse(::google::protobuf::Arena* arena, const AuthResponse& from);
  AuthResponse(::google::protobuf::Arena* arena, AuthResponse&& from) noexcept
      : AuthResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kAuthTokenFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string user_id = 2;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string error_message = 3;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // string auth_token = 4;
  void clear_auth_token() ;
  const std::string& auth_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_auth_token(Arg_&& arg, Args_... args);
  std::string* mutable_auth_token();
  PROTOBUF_NODISCARD std::string* release_auth_token();
  void set_allocated_auth_token(std::string* value);

  private:
  const std::string& _internal_auth_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_token(
      const std::string& value);
  std::string* _internal_mutable_auth_token();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:AuthResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AuthResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr auth_token_;
    bool success_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChatMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChatMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChatMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChatMessage(const ChatMessage& from) : ChatMessage(nullptr, from) {}
  inline ChatMessage(ChatMessage&& from) noexcept
      : ChatMessage(nullptr, std::move(from)) {}
  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
        &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ChatMessage& a, ChatMessage& b) { a.Swap(&b); }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChatMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChatMessage& from) { ChatMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChatMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ChatMessage"; }

 protected:
  explicit ChatMessage(::google::protobuf::Arena* arena);
  ChatMessage(::google::protobuf::Arena* arena, const ChatMessage& from);
  ChatMessage(::google::protobuf::Arena* arena, ChatMessage&& from) noexcept
      : ChatMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kTextFieldNumber = 3,
    kChannelIdFieldNumber = 6,
    kTimestampFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  // string message_id = 1;
  void clear_message_id() ;
  const std::string& message_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message_id(Arg_&& arg, Args_... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* value);

  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(
      const std::string& value);
  std::string* _internal_mutable_message_id();

  public:
  // string user_id = 2;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string text = 3;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // string channel_id = 6;
  void clear_channel_id() ;
  const std::string& channel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* value);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // .google.protobuf.Timestamp timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .MessageType type = 5;
  void clear_type() ;
  ::MessageType type() const;
  void set_type(::MessageType value);

  private:
  ::MessageType _internal_type() const;
  void _internal_set_type(::MessageType value);

  public:
  // @@protoc_insertion_point(class_scope:ChatMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChatMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_id_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr channel_id_;
    ::google::protobuf::Timestamp* timestamp_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ServerMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServerMessage(const ServerMessage& from) : ServerMessage(nullptr, from) {}
  inline ServerMessage(ServerMessage&& from) noexcept
      : ServerMessage(nullptr, std::move(from)) {}
  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageContentCase {
    kLoginRequest = 1,
    kRegisterRequest = 2,
    kAuthResponse = 3,
    kChatMessage = 4,
    kUserUpdate = 5,
    MESSAGE_CONTENT_NOT_SET = 0,
  };
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
        &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ServerMessage& a, ServerMessage& b) { a.Swap(&b); }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerMessage& from) { ServerMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ServerMessage"; }

 protected:
  explicit ServerMessage(::google::protobuf::Arena* arena);
  ServerMessage(::google::protobuf::Arena* arena, const ServerMessage& from);
  ServerMessage(::google::protobuf::Arena* arena, ServerMessage&& from) noexcept
      : ServerMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 6,
    kLoginRequestFieldNumber = 1,
    kRegisterRequestFieldNumber = 2,
    kAuthResponseFieldNumber = 3,
    kChatMessageFieldNumber = 4,
    kUserUpdateFieldNumber = 5,
  };
  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .LoginRequest login_request = 1;
  bool has_login_request() const;
  private:
  bool _internal_has_login_request() const;

  public:
  void clear_login_request() ;
  const ::LoginRequest& login_request() const;
  PROTOBUF_NODISCARD ::LoginRequest* release_login_request();
  ::LoginRequest* mutable_login_request();
  void set_allocated_login_request(::LoginRequest* value);
  void unsafe_arena_set_allocated_login_request(::LoginRequest* value);
  ::LoginRequest* unsafe_arena_release_login_request();

  private:
  const ::LoginRequest& _internal_login_request() const;
  ::LoginRequest* _internal_mutable_login_request();

  public:
  // .RegisterRequest register_request = 2;
  bool has_register_request() const;
  private:
  bool _internal_has_register_request() const;

  public:
  void clear_register_request() ;
  const ::RegisterRequest& register_request() const;
  PROTOBUF_NODISCARD ::RegisterRequest* release_register_request();
  ::RegisterRequest* mutable_register_request();
  void set_allocated_register_request(::RegisterRequest* value);
  void unsafe_arena_set_allocated_register_request(::RegisterRequest* value);
  ::RegisterRequest* unsafe_arena_release_register_request();

  private:
  const ::RegisterRequest& _internal_register_request() const;
  ::RegisterRequest* _internal_mutable_register_request();

  public:
  // .AuthResponse auth_response = 3;
  bool has_auth_response() const;
  private:
  bool _internal_has_auth_response() const;

  public:
  void clear_auth_response() ;
  const ::AuthResponse& auth_response() const;
  PROTOBUF_NODISCARD ::AuthResponse* release_auth_response();
  ::AuthResponse* mutable_auth_response();
  void set_allocated_auth_response(::AuthResponse* value);
  void unsafe_arena_set_allocated_auth_response(::AuthResponse* value);
  ::AuthResponse* unsafe_arena_release_auth_response();

  private:
  const ::AuthResponse& _internal_auth_response() const;
  ::AuthResponse* _internal_mutable_auth_response();

  public:
  // .ChatMessage chat_message = 4;
  bool has_chat_message() const;
  private:
  bool _internal_has_chat_message() const;

  public:
  void clear_chat_message() ;
  const ::ChatMessage& chat_message() const;
  PROTOBUF_NODISCARD ::ChatMessage* release_chat_message();
  ::ChatMessage* mutable_chat_message();
  void set_allocated_chat_message(::ChatMessage* value);
  void unsafe_arena_set_allocated_chat_message(::ChatMessage* value);
  ::ChatMessage* unsafe_arena_release_chat_message();

  private:
  const ::ChatMessage& _internal_chat_message() const;
  ::ChatMessage* _internal_mutable_chat_message();

  public:
  // .User user_update = 5;
  bool has_user_update() const;
  private:
  bool _internal_has_user_update() const;

  public:
  void clear_user_update() ;
  const ::User& user_update() const;
  PROTOBUF_NODISCARD ::User* release_user_update();
  ::User* mutable_user_update();
  void set_allocated_user_update(::User* value);
  void unsafe_arena_set_allocated_user_update(::User* value);
  ::User* unsafe_arena_release_user_update();

  private:
  const ::User& _internal_user_update() const;
  ::User* _internal_mutable_user_update();

  public:
  void clear_message_content();
  MessageContentCase message_content_case() const;
  // @@protoc_insertion_point(class_scope:ServerMessage)
 private:
  class _Internal;
  void set_has_login_request();
  void set_has_register_request();
  void set_has_auth_response();
  void set_has_chat_message();
  void set_has_user_update();
  inline bool has_message_content() const;
  inline void clear_has_message_content();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ServerMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* timestamp_;
    union MessageContentUnion {
      constexpr MessageContentUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::LoginRequest* login_request_;
      ::RegisterRequest* register_request_;
      ::AuthResponse* auth_response_;
      ::ChatMessage* chat_message_;
      ::User* user_update_;
    } message_content_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RegisterRequest

// string username = 1;
inline void RegisterRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& RegisterRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RegisterRequest.username)
}
inline std::string* RegisterRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:RegisterRequest.username)
  return _s;
}
inline const std::string& RegisterRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void RegisterRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:RegisterRequest.username)
  return _impl_.username_.Release();
}
inline void RegisterRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRequest.username)
}

// string password = 2;
inline void RegisterRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RegisterRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RegisterRequest.password)
}
inline std::string* RegisterRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:RegisterRequest.password)
  return _s;
}
inline const std::string& RegisterRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void RegisterRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:RegisterRequest.password)
  return _impl_.password_.Release();
}
inline void RegisterRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRequest.password)
}

// string email = 3;
inline void RegisterRequest::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& RegisterRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RegisterRequest.email)
}
inline std::string* RegisterRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:RegisterRequest.email)
  return _s;
}
inline const std::string& RegisterRequest::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void RegisterRequest::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:RegisterRequest.email)
  return _impl_.email_.Release();
}
inline void RegisterRequest::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRequest.email)
}

// string display_name = 4;
inline void RegisterRequest::clear_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& RegisterRequest::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterRequest.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RegisterRequest.display_name)
}
inline std::string* RegisterRequest::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:RegisterRequest.display_name)
  return _s;
}
inline const std::string& RegisterRequest::_internal_display_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.display_name_.Get();
}
inline void RegisterRequest::_internal_set_display_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:RegisterRequest.display_name)
  return _impl_.display_name_.Release();
}
inline void RegisterRequest::set_allocated_display_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRequest.display_name)
}

// -------------------------------------------------------------------

// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LoginRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:LoginRequest.username)
  return _s;
}
inline const std::string& LoginRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LoginRequest.username)
  return _impl_.username_.Release();
}
inline void LoginRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.username)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LoginRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.password)
}

// -------------------------------------------------------------------

// AuthResponse

// bool success = 1;
inline void AuthResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool AuthResponse::success() const {
  // @@protoc_insertion_point(field_get:AuthResponse.success)
  return _internal_success();
}
inline void AuthResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:AuthResponse.success)
}
inline bool AuthResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void AuthResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string user_id = 2;
inline void AuthResponse::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AuthResponse::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AuthResponse.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthResponse::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AuthResponse.user_id)
}
inline std::string* AuthResponse::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:AuthResponse.user_id)
  return _s;
}
inline const std::string& AuthResponse::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void AuthResponse::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* AuthResponse::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* AuthResponse::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AuthResponse.user_id)
  return _impl_.user_id_.Release();
}
inline void AuthResponse::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthResponse.user_id)
}

// string error_message = 3;
inline void AuthResponse::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& AuthResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AuthResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AuthResponse.error_message)
}
inline std::string* AuthResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:AuthResponse.error_message)
  return _s;
}
inline const std::string& AuthResponse::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void AuthResponse::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* AuthResponse::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* AuthResponse::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AuthResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void AuthResponse::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthResponse.error_message)
}

// string auth_token = 4;
inline void AuthResponse::clear_auth_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auth_token_.ClearToEmpty();
}
inline const std::string& AuthResponse::auth_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AuthResponse.auth_token)
  return _internal_auth_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthResponse::set_auth_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auth_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AuthResponse.auth_token)
}
inline std::string* AuthResponse::mutable_auth_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_auth_token();
  // @@protoc_insertion_point(field_mutable:AuthResponse.auth_token)
  return _s;
}
inline const std::string& AuthResponse::_internal_auth_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auth_token_.Get();
}
inline void AuthResponse::_internal_set_auth_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auth_token_.Set(value, GetArena());
}
inline std::string* AuthResponse::_internal_mutable_auth_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.auth_token_.Mutable( GetArena());
}
inline std::string* AuthResponse::release_auth_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AuthResponse.auth_token)
  return _impl_.auth_token_.Release();
}
inline void AuthResponse::set_allocated_auth_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auth_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.auth_token_.IsDefault()) {
    _impl_.auth_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthResponse.auth_token)
}

// -------------------------------------------------------------------

// User

// string user_id = 1;
inline void User::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& User::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:User.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:User.user_id)
}
inline std::string* User::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:User.user_id)
  return _s;
}
inline const std::string& User::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void User::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* User::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:User.user_id)
  return _impl_.user_id_.Release();
}
inline void User::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:User.user_id)
}

// string username = 2;
inline void User::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& User::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:User.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:User.username)
}
inline std::string* User::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* User::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:User.username)
  return _impl_.username_.Release();
}
inline void User::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:User.username)
}

// string display_name = 3;
inline void User::clear_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& User::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:User.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:User.display_name)
}
inline std::string* User::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:User.display_name)
  return _s;
}
inline const std::string& User::_internal_display_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.display_name_.Get();
}
inline void User::_internal_set_display_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* User::release_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:User.display_name)
  return _impl_.display_name_.Release();
}
inline void User::set_allocated_display_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:User.display_name)
}

// .UserStatus status = 4;
inline void User::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::UserStatus User::status() const {
  // @@protoc_insertion_point(field_get:User.status)
  return _internal_status();
}
inline void User::set_status(::UserStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:User.status)
}
inline ::UserStatus User::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::UserStatus>(_impl_.status_);
}
inline void User::_internal_set_status(::UserStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// ChatMessage

// string message_id = 1;
inline void ChatMessage::clear_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::message_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChatMessage.message_id)
  return _internal_message_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_message_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChatMessage.message_id)
}
inline std::string* ChatMessage::mutable_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:ChatMessage.message_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_message_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_id_.Get();
}
inline void ChatMessage::_internal_set_message_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_id_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ChatMessage.message_id)
  return _impl_.message_id_.Release();
}
inline void ChatMessage::set_allocated_message_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.message_id)
}

// string user_id = 2;
inline void ChatMessage::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChatMessage.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChatMessage.user_id)
}
inline std::string* ChatMessage::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ChatMessage.user_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void ChatMessage::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ChatMessage.user_id)
  return _impl_.user_id_.Release();
}
inline void ChatMessage::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.user_id)
}

// string text = 3;
inline void ChatMessage::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& ChatMessage::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChatMessage.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_text(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChatMessage.text)
}
inline std::string* ChatMessage::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ChatMessage.text)
  return _s;
}
inline const std::string& ChatMessage::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void ChatMessage::_internal_set_text(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ChatMessage.text)
  return _impl_.text_.Release();
}
inline void ChatMessage::set_allocated_text(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.text)
}

// .google.protobuf.Timestamp timestamp = 4;
inline bool ChatMessage::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ChatMessage::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ChatMessage::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChatMessage.timestamp)
  return _internal_timestamp();
}
inline void ChatMessage::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChatMessage.timestamp)
}
inline ::google::protobuf::Timestamp* ChatMessage::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* ChatMessage::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ChatMessage.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ChatMessage::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* ChatMessage::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:ChatMessage.timestamp)
  return _msg;
}
inline void ChatMessage::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.timestamp)
}

// .MessageType type = 5;
inline void ChatMessage::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::MessageType ChatMessage::type() const {
  // @@protoc_insertion_point(field_get:ChatMessage.type)
  return _internal_type();
}
inline void ChatMessage::set_type(::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ChatMessage.type)
}
inline ::MessageType ChatMessage::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::MessageType>(_impl_.type_);
}
inline void ChatMessage::_internal_set_type(::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string channel_id = 6;
inline void ChatMessage::clear_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChatMessage.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChatMessage.channel_id)
}
inline std::string* ChatMessage::mutable_channel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ChatMessage.channel_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_id_.Get();
}
inline void ChatMessage::_internal_set_channel_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.channel_id_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ChatMessage.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChatMessage::set_allocated_channel_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.channel_id_.IsDefault()) {
    _impl_.channel_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.channel_id)
}

// -------------------------------------------------------------------

// VoiceMessage

// bytes audio_data = 1;
inline void VoiceMessage::clear_audio_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_data_.ClearToEmpty();
}
inline const std::string& VoiceMessage::audio_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:VoiceMessage.audio_data)
  return _internal_audio_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VoiceMessage::set_audio_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:VoiceMessage.audio_data)
}
inline std::string* VoiceMessage::mutable_audio_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:VoiceMessage.audio_data)
  return _s;
}
inline const std::string& VoiceMessage::_internal_audio_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audio_data_.Get();
}
inline void VoiceMessage::_internal_set_audio_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_data_.Set(value, GetArena());
}
inline std::string* VoiceMessage::_internal_mutable_audio_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.audio_data_.Mutable( GetArena());
}
inline std::string* VoiceMessage::release_audio_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:VoiceMessage.audio_data)
  return _impl_.audio_data_.Release();
}
inline void VoiceMessage::set_allocated_audio_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.audio_data_.IsDefault()) {
    _impl_.audio_data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:VoiceMessage.audio_data)
}

// int32 duration_seconds = 2;
inline void VoiceMessage::clear_duration_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_seconds_ = 0;
}
inline ::int32_t VoiceMessage::duration_seconds() const {
  // @@protoc_insertion_point(field_get:VoiceMessage.duration_seconds)
  return _internal_duration_seconds();
}
inline void VoiceMessage::set_duration_seconds(::int32_t value) {
  _internal_set_duration_seconds(value);
  // @@protoc_insertion_point(field_set:VoiceMessage.duration_seconds)
}
inline ::int32_t VoiceMessage::_internal_duration_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_seconds_;
}
inline void VoiceMessage::_internal_set_duration_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_seconds_ = value;
}

// -------------------------------------------------------------------

// FileMessage

// string file_name = 1;
inline void FileMessage::clear_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& FileMessage::file_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:FileMessage.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileMessage::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:FileMessage.file_name)
}
inline std::string* FileMessage::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:FileMessage.file_name)
  return _s;
}
inline const std::string& FileMessage::_internal_file_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_name_.Get();
}
inline void FileMessage::_internal_set_file_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.Set(value, GetArena());
}
inline std::string* FileMessage::_internal_mutable_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.file_name_.Mutable( GetArena());
}
inline std::string* FileMessage::release_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:FileMessage.file_name)
  return _impl_.file_name_.Release();
}
inline void FileMessage::set_allocated_file_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:FileMessage.file_name)
}

// bytes file_data = 2;
inline void FileMessage::clear_file_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_data_.ClearToEmpty();
}
inline const std::string& FileMessage::file_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:FileMessage.file_data)
  return _internal_file_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileMessage::set_file_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:FileMessage.file_data)
}
inline std::string* FileMessage::mutable_file_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_data();
  // @@protoc_insertion_point(field_mutable:FileMessage.file_data)
  return _s;
}
inline const std::string& FileMessage::_internal_file_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_data_.Get();
}
inline void FileMessage::_internal_set_file_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_data_.Set(value, GetArena());
}
inline std::string* FileMessage::_internal_mutable_file_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.file_data_.Mutable( GetArena());
}
inline std::string* FileMessage::release_file_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:FileMessage.file_data)
  return _impl_.file_data_.Release();
}
inline void FileMessage::set_allocated_file_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.file_data_.IsDefault()) {
    _impl_.file_data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:FileMessage.file_data)
}

// int64 file_size = 3;
inline void FileMessage::clear_file_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_size_ = ::int64_t{0};
}
inline ::int64_t FileMessage::file_size() const {
  // @@protoc_insertion_point(field_get:FileMessage.file_size)
  return _internal_file_size();
}
inline void FileMessage::set_file_size(::int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:FileMessage.file_size)
}
inline ::int64_t FileMessage::_internal_file_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_size_;
}
inline void FileMessage::_internal_set_file_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_size_ = value;
}

// -------------------------------------------------------------------

// ServerMessage

// .LoginRequest login_request = 1;
inline bool ServerMessage::has_login_request() const {
  return message_content_case() == kLoginRequest;
}
inline bool ServerMessage::_internal_has_login_request() const {
  return message_content_case() == kLoginRequest;
}
inline void ServerMessage::set_has_login_request() {
  _impl_._oneof_case_[0] = kLoginRequest;
}
inline void ServerMessage::clear_login_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_content_case() == kLoginRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.message_content_.login_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_content_.login_request_);
    }
    clear_has_message_content();
  }
}
inline ::LoginRequest* ServerMessage::release_login_request() {
  // @@protoc_insertion_point(field_release:ServerMessage.login_request)
  if (message_content_case() == kLoginRequest) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.login_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_content_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LoginRequest& ServerMessage::_internal_login_request() const {
  return message_content_case() == kLoginRequest ? *_impl_.message_content_.login_request_ : reinterpret_cast<::LoginRequest&>(::_LoginRequest_default_instance_);
}
inline const ::LoginRequest& ServerMessage::login_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ServerMessage.login_request)
  return _internal_login_request();
}
inline ::LoginRequest* ServerMessage::unsafe_arena_release_login_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerMessage.login_request)
  if (message_content_case() == kLoginRequest) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.login_request_;
    _impl_.message_content_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_login_request(::LoginRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message_content();
  if (value) {
    set_has_login_request();
    _impl_.message_content_.login_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.login_request)
}
inline ::LoginRequest* ServerMessage::_internal_mutable_login_request() {
  if (message_content_case() != kLoginRequest) {
    clear_message_content();
    set_has_login_request();
    _impl_.message_content_.login_request_ =
        ::google::protobuf::Message::DefaultConstruct<::LoginRequest>(GetArena());
  }
  return _impl_.message_content_.login_request_;
}
inline ::LoginRequest* ServerMessage::mutable_login_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::LoginRequest* _msg = _internal_mutable_login_request();
  // @@protoc_insertion_point(field_mutable:ServerMessage.login_request)
  return _msg;
}

// .RegisterRequest register_request = 2;
inline bool ServerMessage::has_register_request() const {
  return message_content_case() == kRegisterRequest;
}
inline bool ServerMessage::_internal_has_register_request() const {
  return message_content_case() == kRegisterRequest;
}
inline void ServerMessage::set_has_register_request() {
  _impl_._oneof_case_[0] = kRegisterRequest;
}
inline void ServerMessage::clear_register_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_content_case() == kRegisterRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.message_content_.register_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_content_.register_request_);
    }
    clear_has_message_content();
  }
}
inline ::RegisterRequest* ServerMessage::release_register_request() {
  // @@protoc_insertion_point(field_release:ServerMessage.register_request)
  if (message_content_case() == kRegisterRequest) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.register_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_content_.register_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RegisterRequest& ServerMessage::_internal_register_request() const {
  return message_content_case() == kRegisterRequest ? *_impl_.message_content_.register_request_ : reinterpret_cast<::RegisterRequest&>(::_RegisterRequest_default_instance_);
}
inline const ::RegisterRequest& ServerMessage::register_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ServerMessage.register_request)
  return _internal_register_request();
}
inline ::RegisterRequest* ServerMessage::unsafe_arena_release_register_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerMessage.register_request)
  if (message_content_case() == kRegisterRequest) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.register_request_;
    _impl_.message_content_.register_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_register_request(::RegisterRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message_content();
  if (value) {
    set_has_register_request();
    _impl_.message_content_.register_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.register_request)
}
inline ::RegisterRequest* ServerMessage::_internal_mutable_register_request() {
  if (message_content_case() != kRegisterRequest) {
    clear_message_content();
    set_has_register_request();
    _impl_.message_content_.register_request_ =
        ::google::protobuf::Message::DefaultConstruct<::RegisterRequest>(GetArena());
  }
  return _impl_.message_content_.register_request_;
}
inline ::RegisterRequest* ServerMessage::mutable_register_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RegisterRequest* _msg = _internal_mutable_register_request();
  // @@protoc_insertion_point(field_mutable:ServerMessage.register_request)
  return _msg;
}

// .AuthResponse auth_response = 3;
inline bool ServerMessage::has_auth_response() const {
  return message_content_case() == kAuthResponse;
}
inline bool ServerMessage::_internal_has_auth_response() const {
  return message_content_case() == kAuthResponse;
}
inline void ServerMessage::set_has_auth_response() {
  _impl_._oneof_case_[0] = kAuthResponse;
}
inline void ServerMessage::clear_auth_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_content_case() == kAuthResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.message_content_.auth_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_content_.auth_response_);
    }
    clear_has_message_content();
  }
}
inline ::AuthResponse* ServerMessage::release_auth_response() {
  // @@protoc_insertion_point(field_release:ServerMessage.auth_response)
  if (message_content_case() == kAuthResponse) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.auth_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_content_.auth_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AuthResponse& ServerMessage::_internal_auth_response() const {
  return message_content_case() == kAuthResponse ? *_impl_.message_content_.auth_response_ : reinterpret_cast<::AuthResponse&>(::_AuthResponse_default_instance_);
}
inline const ::AuthResponse& ServerMessage::auth_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ServerMessage.auth_response)
  return _internal_auth_response();
}
inline ::AuthResponse* ServerMessage::unsafe_arena_release_auth_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerMessage.auth_response)
  if (message_content_case() == kAuthResponse) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.auth_response_;
    _impl_.message_content_.auth_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_auth_response(::AuthResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message_content();
  if (value) {
    set_has_auth_response();
    _impl_.message_content_.auth_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.auth_response)
}
inline ::AuthResponse* ServerMessage::_internal_mutable_auth_response() {
  if (message_content_case() != kAuthResponse) {
    clear_message_content();
    set_has_auth_response();
    _impl_.message_content_.auth_response_ =
        ::google::protobuf::Message::DefaultConstruct<::AuthResponse>(GetArena());
  }
  return _impl_.message_content_.auth_response_;
}
inline ::AuthResponse* ServerMessage::mutable_auth_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AuthResponse* _msg = _internal_mutable_auth_response();
  // @@protoc_insertion_point(field_mutable:ServerMessage.auth_response)
  return _msg;
}

// .ChatMessage chat_message = 4;
inline bool ServerMessage::has_chat_message() const {
  return message_content_case() == kChatMessage;
}
inline bool ServerMessage::_internal_has_chat_message() const {
  return message_content_case() == kChatMessage;
}
inline void ServerMessage::set_has_chat_message() {
  _impl_._oneof_case_[0] = kChatMessage;
}
inline void ServerMessage::clear_chat_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_content_case() == kChatMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_content_.chat_message_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_content_.chat_message_);
    }
    clear_has_message_content();
  }
}
inline ::ChatMessage* ServerMessage::release_chat_message() {
  // @@protoc_insertion_point(field_release:ServerMessage.chat_message)
  if (message_content_case() == kChatMessage) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.chat_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_content_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChatMessage& ServerMessage::_internal_chat_message() const {
  return message_content_case() == kChatMessage ? *_impl_.message_content_.chat_message_ : reinterpret_cast<::ChatMessage&>(::_ChatMessage_default_instance_);
}
inline const ::ChatMessage& ServerMessage::chat_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ServerMessage.chat_message)
  return _internal_chat_message();
}
inline ::ChatMessage* ServerMessage::unsafe_arena_release_chat_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerMessage.chat_message)
  if (message_content_case() == kChatMessage) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.chat_message_;
    _impl_.message_content_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_chat_message(::ChatMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message_content();
  if (value) {
    set_has_chat_message();
    _impl_.message_content_.chat_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.chat_message)
}
inline ::ChatMessage* ServerMessage::_internal_mutable_chat_message() {
  if (message_content_case() != kChatMessage) {
    clear_message_content();
    set_has_chat_message();
    _impl_.message_content_.chat_message_ =
        ::google::protobuf::Message::DefaultConstruct<::ChatMessage>(GetArena());
  }
  return _impl_.message_content_.chat_message_;
}
inline ::ChatMessage* ServerMessage::mutable_chat_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChatMessage* _msg = _internal_mutable_chat_message();
  // @@protoc_insertion_point(field_mutable:ServerMessage.chat_message)
  return _msg;
}

// .User user_update = 5;
inline bool ServerMessage::has_user_update() const {
  return message_content_case() == kUserUpdate;
}
inline bool ServerMessage::_internal_has_user_update() const {
  return message_content_case() == kUserUpdate;
}
inline void ServerMessage::set_has_user_update() {
  _impl_._oneof_case_[0] = kUserUpdate;
}
inline void ServerMessage::clear_user_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_content_case() == kUserUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.message_content_.user_update_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_content_.user_update_);
    }
    clear_has_message_content();
  }
}
inline ::User* ServerMessage::release_user_update() {
  // @@protoc_insertion_point(field_release:ServerMessage.user_update)
  if (message_content_case() == kUserUpdate) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.user_update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_content_.user_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::User& ServerMessage::_internal_user_update() const {
  return message_content_case() == kUserUpdate ? *_impl_.message_content_.user_update_ : reinterpret_cast<::User&>(::_User_default_instance_);
}
inline const ::User& ServerMessage::user_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ServerMessage.user_update)
  return _internal_user_update();
}
inline ::User* ServerMessage::unsafe_arena_release_user_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerMessage.user_update)
  if (message_content_case() == kUserUpdate) {
    clear_has_message_content();
    auto* temp = _impl_.message_content_.user_update_;
    _impl_.message_content_.user_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_user_update(::User* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message_content();
  if (value) {
    set_has_user_update();
    _impl_.message_content_.user_update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.user_update)
}
inline ::User* ServerMessage::_internal_mutable_user_update() {
  if (message_content_case() != kUserUpdate) {
    clear_message_content();
    set_has_user_update();
    _impl_.message_content_.user_update_ =
        ::google::protobuf::Message::DefaultConstruct<::User>(GetArena());
  }
  return _impl_.message_content_.user_update_;
}
inline ::User* ServerMessage::mutable_user_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::User* _msg = _internal_mutable_user_update();
  // @@protoc_insertion_point(field_mutable:ServerMessage.user_update)
  return _msg;
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool ServerMessage::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ServerMessage::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ServerMessage::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ServerMessage.timestamp)
  return _internal_timestamp();
}
inline void ServerMessage::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.timestamp)
}
inline ::google::protobuf::Timestamp* ServerMessage::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* ServerMessage::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ServerMessage.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ServerMessage::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* ServerMessage::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:ServerMessage.timestamp)
  return _msg;
}
inline void ServerMessage::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ServerMessage.timestamp)
}

inline bool ServerMessage::has_message_content() const {
  return message_content_case() != MESSAGE_CONTENT_NOT_SET;
}
inline void ServerMessage::clear_has_message_content() {
  _impl_._oneof_case_[0] = MESSAGE_CONTENT_NOT_SET;
}
inline ServerMessage::MessageContentCase ServerMessage::message_content_case() const {
  return ServerMessage::MessageContentCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::UserStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::UserStatus>() {
  return ::UserStatus_descriptor();
}
template <>
struct is_proto_enum<::MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MessageType>() {
  return ::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // messages_2eproto_2epb_2eh
